<div><div class="reading-title css-1hxq2bi"><h1 class="cds-321 css-1diqjn6 cds-323" tabindex="-1">Determine the most efficient query</h1><div class="css-1kuhxiq"></div></div><div class="rc-CML" dir="auto"><div><div data-track="true" data-track-app="open_course_home" data-track-page="item_layout" data-track-action="click" data-track-component="cml" role="presentation"><div data-track="true" data-track-app="open_course_home" data-track-page="item_layout" data-track-action="click" data-track-component="cml_link"><div data-testid="cml-viewer" class="css-1k5v0wb"><p><span><span>So far, you have learned about the factors that affect database performance and database query optimization. This is an important part of a BI professional’s work because it allows them to ensure that the tools and systems their team is using are as efficient as possible. Now that you’re more familiar with these concepts, you’ll review an example.&nbsp;</span></span></p><h2 data-heading-variant="h2semibold"><span><span>The scenario</span></span></h2><p><span><span>Francisco’s Electronics recently launched its home office product line on its e-commerce site. After receiving a positive response from customers, company decision-makers chose to add the rest of their products to the site. Since launch, they have received more than 10,000,000 sales. While this is great for the business, such a massive catalog of sales records has affected the speed of their database. The sales manager, Ed, wanted to run a query for the number of sales created after November 1, 2021, in the “electronics” category but was unable to because the database was too slow. He asked Xavier, a BI analyst, to work with the database and optimize a query to speed up the sales report generation.</span></span></p><p><span><span>To begin, Xavier examined the </span></span><span><strong><span>sales_warehouse</span></strong></span><span><span> database schema shown below. The schema contains different symbols and connectors that represent two important pieces of information: the major tables within the system and the relationships among these tables.</span></span></p><div><span><span></span></span><figure role="figure" contenteditable="false"><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/G9CCvLoBTcGFb8N_27C5Dw_83c1e162d80d4b23b96fb3fdce82c0f1_BI_R-125.png?expiry=1687046400000&amp;hmac=l9Gksglt1mqXdFJIn6op-Ou-hywzUDrv8_PRzPA47J4" alt="The sales_warehouse database schema. The Sales table connects to the Products, Users, Locations, and Orders tables." data-asset-id="G9CCvLoBTcGFb8N_27C5Dw" class="cml-image-default undefined"></figure></div><p><span><span>The </span></span><span><strong><span>sales_warehouse</span></strong></span><span><span> database schema contains five tables—Sales, Products, Users, Locations, and Orders—which are connected via keys. The tables contain five to eight columns (or attributes) ranging in data type. The data types include varchar or char (or character), integer, decimal, date, text (or string), timestamp, and bit.</span></span></p><p><span><span>The foreign keys in the Sales table link to each of the other tables. The “product_id” foreign key links to the Products table, the “user_id” foreign key links to the Users table, the “order_id” foreign key links to the Orders table, and the “shipping_address_id” and “billing_address_id” foreign keys link to the Locations table.</span></span></p><h2 data-heading-variant="h2semibold"><span><span>Examining the SQL query</span></span></h2><p><span><span>After considering the details, Xavier found that the following request needed optimization:</span></span></p><div><span><span></span></span><figure role="figure" contenteditable="false"><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/npZKji5pSKiWSo4uaZioJQ_88ab47ec4afd4a428cc494c8547334f1_Screen-Shot-2022-09-30-at-11.12.56.png?expiry=1687046400000&amp;hmac=kMTZ5OqJgy0pL5BBOTwQ2wLG2TslAqJtitP2Z1UnijI" alt="" data-asset-id="npZKji5pSKiWSo4uaZioJQ" class="cml-image-default undefined"></figure></div><h2 data-heading-variant="h2semibold"><span><span>Optimizing the query</span></span></h2><p><span><span>To make this query more efficient, Xavier started by checking if the "date" and "category" fields were indexed. He did this by running the following queries:</span></span></p><div><span><span></span></span><figure role="figure" contenteditable="false"><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/d7GMSi2vSjyxjEotr-o8tQ_1523b701369548a194011a95efc6c2f1_Screen-Shot-2022-09-30-at-11.13.01.png?expiry=1687046400000&amp;hmac=GCve0x18klBBjZJ1Kd1REiRIoQzUq5a68u4XFn1XsLI" alt="" data-asset-id="d7GMSi2vSjyxjEotr-o8tQ" class="cml-image-default undefined"></figure></div><p><span><span>Without indexes in the columns used for query restrictions, the engine did a full table scan that processed all several million records and checked which ones had date &gt;= “2021-11-01” and category = “electronics.”&nbsp;</span></span></p><p><span><span>Then, he indexed the “date” field in the Sales table and the “category” field in the Products table using the following SQL code:</span></span></p><p><span><span></span></span></p><div><span><span></span></span><figure role="figure" contenteditable="false"><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/OpNDjoCsQh2TQ46ArCIdjA_e2a8064a21504502a205382deb8623f1_Screen-Shot-2022-09-30-at-11.13.07.png?expiry=1687046400000&amp;hmac=lc3tOGkuxBBM179qUtAUZxrDiskecxAqSKdmMGSkbIo" alt="" data-asset-id="OpNDjoCsQh2TQ46ArCIdjA" class="cml-image-default undefined"></figure></div><p><span><span>Unfortunately, the query was still slow, even after adding the indices. Assuming that there were only a few thousand sales created after “2021-11-01,” the query still created a very large virtual table (joining Sales and Products). It had millions of records before filtering out sales with a date after “2021-11-01” and sales with products in “electronics” categories. This resulted in an inefficient and slow query.</span></span></p><p><span><span>To make the query faster and more efficient, Xavier modified it to first filter out the sales with dates after “2021-11-01.” The query “(</span></span><span><strong><span>SELECT </span></strong></span><span><span>product_id </span></span><span><strong><span>FROM </span></strong></span><span><span>Sales </span></span><span><strong><span>WHERE </span></strong></span><span><span>date &gt; '2021-11-01') </span></span><span><strong><span>AS</span></strong></span><span><span> oi” returned only a few thousand records, rather than millions of records. He then joined these records with the Products table.&nbsp;</span></span></p><p><span><span>Xavier’s final optimized query was:</span></span></p><p><span><span></span></span></p><div><span><span></span></span><figure role="figure" contenteditable="false"><img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/yljK8XfkT2eYyvF35A9nQQ_0531086da17a49c7973dfd5f9ebb93f1_Screen-Shot-2022-09-30-at-11.13.11.png?expiry=1687046400000&amp;hmac=SZ7RFzpVETiM7zdT02svqob2nqINteNP0_v_0NwV8q0" alt="" data-asset-id="yljK8XfkT2eYyvF35A9nQQ" class="cml-image-default undefined"></figure></div><h2 data-heading-variant="h2semibold"><span><span>Key takeaways</span></span></h2><p><span><span>Optimizing queries will make your pipeline operations faster and more efficient. In your role as a BI professional, you might work on projects with extremely large datasets. For these projects, it’s important to write SQL queries that are as fast and efficient as possible. Otherwise, your data pipelines might be slow and difficult to work with.</span></span></p><p><span><span>
</span></span></p></div></div></div></div></div><div data-testid="reading-complete-container" class="css-rj3g7z"><div><button class="cds-318 cds-289 cds-291  css-zosuv5 cds-300 cds-button-disableElevation" tabindex="0" type="submit" data-testid="mark-complete"><span class="cds-290 cds-button-label">Mark as completed</span></button></div></div></div>
